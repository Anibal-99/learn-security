El pentesting o pruebas de penetración es un proceso crucial que ayuda a identificar vulnerabilidades en sistemas informáticos, redes y aplicaciones web. Se trata de un ataque simulado a un sistema, con el objetivo de identificar fallos de seguridad que podrían ser explotados por piratas informáticos. Una hoja de ruta para el pentesting es esencial para garantizar que el proceso se lleva a cabo de forma sistemática y exhaustiva.

## Step 1: Planning and Preparation

El primer paso de la hoja de ruta del pentesting es la planificación y la preparación. Esto implica definir el alcance de la prueba, acordar los objetivos y obtener el permiso de los propietarios del sistema. El equipo de pruebas también debe identificar los activos que se van a probar, incluidas aplicaciones, redes y dispositivos.

## Step 2: Information Gathering

La recopilación de información es una fase crítica del pentesting, en la que el equipo de pruebas recopila toda la información posible sobre el sistema objetivo. Esto incluye la identificación del sistema operativo, las versiones de software, la topología de red y los puertos abiertos en el sistema. El equipo puede utilizar varias herramientas, incluidos escáneres de vulnerabilidades y mapeadores de red, para recopilar esta información.

## Step 3: Vulnerability Analysis

Una vez completada la fase de recopilación de información, el equipo analiza las vulnerabilidades identificadas en el sistema objetivo. El equipo puede utilizar herramientas como Nessus, OpenVAS y Burp Suite para identificar vulnerabilidades en el sistema. A continuación, el equipo prioriza las vulnerabilidades en función de su gravedad e impacto potencial en el sistema.

## Step 4: Exploitation

La fase de explotación consiste en aprovechar las vulnerabilidades identificadas para obtener acceso al sistema objetivo. El equipo de pruebas utiliza varias herramientas, incluido Metasploit, para explotar las vulnerabilidades. El objetivo de esta fase es determinar el alcance de los daños que puede causar un posible atacante.

## Step 5: Reporting

La fase final de la hoja de ruta es la elaboración de informes. El equipo de pruebas documenta las vulnerabilidades identificadas, junto con las recomendaciones para remediarlas. El informe debe ser claro, conciso y fácil de entender para las partes interesadas no técnicas.

En conclusión, una hoja de ruta para el pentesting es fundamental para garantizar que el proceso se lleva a cabo de forma sistemática y exhaustiva. Ayuda a identificar vulnerabilidades y proporciona recomendaciones para remediarlas, mejorando así la seguridad del sistema objetivo.

# Web Goat

## Protocolos

En esta sección, discutiremos algunos de los protocolos más comunes utilizados en redes y su importancia en el mantenimiento de la ciberseguridad. Los protocolos son un conjunto de reglas y procedimientos que definen cómo deben transmitirse, formatearse y procesarse los datos en una red.

### Protocolor de transferencia de hipertextu (HTTP) y HTTPS

HTTP, o Protocolo de Transferencia de Hipertexto, es la base de la comunicación de datos en la World Wide Web. Define cómo deben formatearse y transmitirse los datos entre un cliente (como tu navegador) y un servidor web. HTTP es un protocolo sin estado, lo que significa que cada par de solicitud y respuesta es independiente de los demás.

HTTPS, o HTTP Secure, es una versión segura de HTTP que encripta los datos entre el cliente y el servidor utilizando Secure Sockets Layer (SSL) o Transport Layer Security (TLS) para proteger los datos sensibles de ser interceptados o manipulados.

### Protocolo de control de transmision (TCP)

TCP, o Protocolo de Control de Transmisión, es un protocolo fiable y orientado a la conexión que garantiza la correcta entrega de datos entre aplicaciones a través de una red. Garantiza una entrega de datos precisa y completa estableciendo una conexión, segmentando los datos en paquetes más pequeños, verificando la recepción de los paquetes y reordenando los paquetes a su secuencia original.

### Protocolo de internet (IP)

El Protocolo de Internet (IP) es responsable de la entrega de paquetes desde el host de origen al host de destino basándose en sus direcciones IP. IP es el protocolo principal de la capa de Internet del conjunto de protocolos de Internet y tiene dos versiones principales: IPv4 e IPv6.

### Protocolo de datagrama de usuario (UDP)

UDP, o Protocolo de Datagramas de Usuario, es un protocolo de comunicación sin conexión utilizado para la transmisión rápida y eficiente de datos. A diferencia de TCP, UDP no proporciona comprobación de errores ni garantiza la entrega, por lo que es adecuado para aplicaciones en tiempo real como el streaming de vídeo y los juegos en línea, donde la baja latencia es crucial.

### Sistema de nombre de dominio (DNS)

El Sistema de Nombres de Dominio (DNS) es responsable de traducir nombres de dominio legibles por humanos (como [www.example.com](http://www.example.com/)) en las correspondientes direcciones IP que los ordenadores entienden. Este proceso se denomina resolución de nombres de dominio. El DNS es un componente esencial de la comunicación por Internet, ya que permite a los usuarios acceder a sitios web utilizando nombres fáciles de recordar en lugar de direcciones IP numéricas.

### Protocolo de transferencia de archivos (FTP)

El Protocolo de Transferencia de Archivos (FTP) es un protocolo de red estándar utilizado para transferir archivos de un host a otro a través de una red basada en TCP, como Internet. FTP se utiliza habitualmente para compartir archivos y transferir archivos entre un cliente y un servidor.

### Procolo simple de transferencia de correo (SMTP)

El Protocolo Simple de Transferencia de Correo (SMTP) es el protocolo estándar para enviar mensajes de correo electrónico a través de una red. Define cómo deben formatearse, cifrarse y retransmitirse los mensajes de correo electrónico entre clientes, servidores y otros sistemas de correo electrónico.

Comprender estos protocolos comunes y sus funciones en la comunicación de red es vital para garantizar la correcta aplicación de las medidas de ciberseguridad. Le ayudará a identificar mejor las vulnerabilidades potenciales y a tomar decisiones informadas sobre las estrategias de defensa de la red.

## HTTP basico, intercepcion de peticiones HTTP

La interceptación de peticiones HTTP es una técnica comúnmente utilizada en el ámbito de la seguridad informática y la ingeniería de software.

Al interceptar las peticiones HTTP, se pueden realizar varias tareas, tales como:

1. **Depuración**: se puede analizar y depurar el tráfico de red para identificar errores y problemas en el funcionamiento de las aplicaciones web.
2. **Análisis de seguridad:** se pueden detectar y prevenir ataques a las aplicaciones web, tales como inyecciones SQL, cross-site scripting (XSS), entre otros.
3. **Pruebas de penetración:** se pueden utilizar herramientas para simular ataques y evaluar la seguridad de las aplicaciones web.
4. **Manipulación de datos:** se pueden modificar los datos que se envían o reciben en las peticiones HTTP para probar diferentes escenarios y ver cómo la aplicación responde a diferentes situaciones.

En resumen, la interceptación de peticiones HTTP es una técnica importante para mejorar la seguridad y la calidad de las aplicaciones web, así como para depurar problemas en su funcionamiento.

## HTTP proxies

Qué es un proxy HTTP

Un proxy es una aplicación que conecta tu cliente HTTP a los recursos backend. Los clientes HTTP pueden ser navegadores o aplicaciones como curl, SOAP UI, Postman, etc. Normalmente, estos proxies se utilizan para enrutar y obtener acceso a Internet cuando no hay conexión directa a Internet desde el propio cliente. Por lo tanto, los proxies HTTP también son ideales cuando estás probando tu aplicación. Siempre puedes utilizar los registros del proxy para ver lo que realmente se envió del cliente al servidor. Así puedes comprobar las cabeceras de petición y respuesta y las cargas útiles XML, JSON u otras.

Los proxies HTTP reciben peticiones de un cliente y las retransmiten. También suelen grabarlas. Actúan como un man-in-the-middle. Incluso funciona bien con o sin HTTPS siempre y cuando su cliente o navegador confíe en el certificado del Proxy HTTP

Los proxies HTTP se utilizan por varias razones, como mejorar el rendimiento, proporcionar filtrado de contenido o de seguridad, y ocultar la dirección IP del cliente.

Algunos ejemplos de casos en los que se pueden utilizar proxies HTTP incluyen:

- Reducción de la carga del servidor: al utilizar un proxy, se pueden almacenar en caché las respuestas del servidor web para que, si un cliente hace una solicitud similar en el futuro, el proxy pueda devolver la respuesta almacenada en caché en lugar de tener que hacer una nueva solicitud al servidor web.
- Control de acceso: un proxy HTTP puede restringir el acceso a ciertos sitios web o tipos de contenido, lo que puede ser útil en entornos como las empresas o las escuelas.
- Anonimato: al utilizar un proxy, la dirección IP del cliente se oculta al servidor web de destino, lo que puede ser útil para los usuarios que desean mantener su anonimato mientras navegan por la web.
- Seguridad: un proxy HTTP puede filtrar y bloquear solicitudes maliciosas o tráfico no deseado para proteger a los usuarios y la red de posibles amenazas.

En resumen, los proxies HTTP son servidores que actúan como intermediarios entre los clientes y los servidores web y se utilizan para mejorar el rendimiento, proporcionar filtrado de contenido o de seguridad y ocultar la dirección IP del cliente.

## Parametros de consulta

Los parámetros de cadena de consulta son un conjunto de valores que se adjuntan a una URL después del signo de interrogación "?" y se utilizan para proporcionar información adicional al servidor web que procesa la solicitud. Estos parámetros se utilizan comúnmente en aplicaciones web para permitir que los usuarios especifiquen opciones, filtros, criterios de búsqueda y otros datos que se utilizarán para personalizar la respuesta del servidor.

Los parámetros de cadena de consulta se especifican en formato clave-valor, donde el nombre del parámetro (clave) se separa del valor por el símbolo "=" y los pares clave-valor se separan entre sí por el símbolo "&". Por ejemplo, en la siguiente URL:

```arduino
https://www.ejemplo.com/buscar?query=ejemplo&filtro=recientes
```

El parámetro "query" tiene un valor de "ejemplo" y el parámetro "filtro" tiene un valor de "recientes". El servidor web que procesa esta solicitud puede utilizar estos parámetros para realizar una búsqueda y devolver los resultados correspondientes.

## La tríada CIA

La tríada CIA (confidencialidad, integridad, disponibilidad) es un modelo de seguridad de la información. Los tres elementos de la tríada se consideran los componentes más cruciales de la seguridad de la información y deben garantizarse en cualquier sistema seguro.

La violación de uno solo de estos elementos puede acarrear graves consecuencias.

La tríada CIA se creó para proporcionar un estándar de referencia para evaluar e implementar la seguridad independientemente del sistema subyacente y/o de la organización.

### Confidencialidad

La confidencialidad es "la propiedad de que la información no esté disponible ni sea revelada a personas, entidades o procesos no autorizados". En otras palabras, la confidencialidad requiere que los usuarios no autorizados no puedan acceder a los recursos sensibles. La confidencialidad debe equilibrarse con la disponibilidad; las personas autorizadas deben seguir teniendo acceso a los recursos para los que se les han concedido permisos.

Aunque la confidencialidad es similar a la "privacidad", estas dos palabras no son intercambiables. En cambio, la confidencialidad es un componente de la privacidad; la confidencialidad se implementa para proteger los recursos de entidades no autorizadas.

**Ejemplos que comprometen la confidencialidad:**

- Un hacker accede a la base de datos de contraseñas de una empresa.
- Se envía un correo electrónico sensible a la persona incorrecta.
- Un hacker lee información sensible interceptando y escuchando una transferencia de información.

**Ejemplos de métodos que garantizan la confidencialidad:**

- Encriptación de datos
- Autenticación y control de acceso correctamente aplicados
    - Contraseñas almacenadas de forma segura
    - Autenticación multifactor (MFA)
    - Verificación biométrica
- Minimización del número de lugares/veces en que aparece la información
- Controles de seguridad física, como salas de servidores debidamente protegidas

### Integridad

La integridad es "la propiedad de exactitud y exhaustividad". En otras palabras, integridad significa mantener la coherencia, exactitud y fiabilidad de los datos durante todo su ciclo de vida. Los datos no deben cambiar durante su tránsito, y las entidades no autorizadas no deben alterarlos.

**Ejemplos que comprometen la integridad:**

- Error humano al introducir los datos.
- Errores durante la transmisión de datos.
- Errores de software y fallos de hardware.
- Los piratas informáticos modifican información a la que no deberían tener acceso.

**Ejemplos de métodos que garantizan la integridad**

- Métodos de autenticación y control de acceso que funcionen correctamente.
- Comprobación de la integridad mediante funciones hash.
- Copias de seguridad y redundancia.
- Auditoría y registro.

### **Disponibilidad**

La disponibilidad es "la propiedad de ser accesible y utilizable bajo demanda por una entidad autorizada". En otras palabras, las personas autorizadas deben tener acceso a los recursos permitidos en todo momento.

**Ejemplos que comprometen la disponibilidad:**

- Ataques de denegación de servicio (DOS).
- Fallos de hardware.
- Incendios u otras catástrofes naturales.
- Errores de configuración del software o de la red.

**Quiz**

1. *¿Cómo podría un intruso perjudicar el objetivo de seguridad de la confidencialidad?*
- [ ]  Borrando todas las bases de datos.
- [ ]  Robando una base de datos en la que se almacena información de configuración general del sistema.
- [x]  Robando una base de datos en la que se almacenan nombres y correos electrónicos y subiéndola a un sitio web.
- [ ]  La confidencialidad no puede ser dañada por un intruso.

1. ¿Cómo podría un intruso perjudicar el objetivo de seguridad de la integridad?
- [x]  Cambiando los nombres y correos electrónicos de uno o varios usuarios almacenados en una base de datos.
- [ ]  Escuchando el tráfico de red entrante y saliente.
- [ ]  Eludiendo los mecanismos de autenticación establecidos para gestionar el acceso a la base de datos.
- [ ]  La integridad sólo puede verse perjudicada cuando el intruso tiene acceso físico al almacenamiento de la base de datos.

1. ¿Cómo podría un intruso perjudicar el objetivo de seguridad de la disponibilidad?
- [ ]  Aprovechando los fallos del software del sistema para eludir los mecanismos de autenticación de las bases de datos.
- [ ]  Redirigiendo correos electrónicos con datos sensibles a otras personas.
- [ ]  La disponibilidad sólo puede verse perjudicada desenchufando la fuente de alimentación de los dispositivos de almacenamiento.
- [x]  Lanzando un ataque de denegación de servicio contra los servidores.

1. ¿Qué ocurre si al menos uno de los objetivos de seguridad de la CIA se ve perjudicado?
- [ ]  Un sistema puede considerarse seguro hasta que todos los objetivos se vean perjudicados. Dañar un objetivo no afecta a la seguridad del sistema.
- [x]  La seguridad del sistema se ve comprometida aunque sólo se vea afectado un objetivo.
- [ ]  No es tan grave que un atacante lea o modifique datos, al menos algunos datos siguen estando disponibles, por lo que la seguridad del sistema sólo se ve comprometida cuando se ve afectado el objetivo de disponibilidad.
- [ ]  No debería ser un problema si un atacante cambia los datos o los hace no disponibles, pero la lectura de datos sensibles no es tolerable. Sólo hay problema cuando se perjudica la confidencialidad.

## Broken access control

### Secuestrar una sesion

Concepto
Los desarrolladores de aplicaciones que desarrollan sus propios identificadores de sesión a menudo olvidan incorporar la complejidad y aleatoriedad necesarias para la seguridad. Si el identificador de sesión específico del usuario no es complejo y aleatorio, la aplicación es muy susceptible a los ataques de fuerza bruta basados en sesiones.

El secuestro de sesión (Session Hijacking) es un ataque en el que un atacante intenta tomar el control de la sesión de un usuario, a menudo mediante la suplantación de la identidad del usuario. Este ataque permite al atacante acceder a información confidencial del usuario y realizar acciones en su nombre.

Hay varios métodos para realizar un secuestro de sesión, pero uno de los más comunes es mediante el uso de herramientas de sniffing de red para interceptar el tráfico de red entre el usuario y el servidor, y robar la información de la sesión, como el ID de sesión, que se utiliza para autenticar al usuario en el servidor. El atacante puede utilizar esta información para asumir la identidad del usuario y realizar acciones en su nombre.

Otro método común para el secuestro de sesión es mediante el uso de técnicas de inyección de scripts en el navegador del usuario, como Cross-Site Scripting (XSS), para robar la información de la sesión.

### **Insecure Direct Object References**

Las Referencias Directas a Objetos Inseguras ocurren cuando una aplicación proporciona acceso directo a objetos basados en la entrada proporcionada por el usuario. Como resultado de esta vulnerabilidad, los atacantes pueden saltarse la autorización y acceder directamente a recursos del sistema, por ejemplo, registros de bases de datos o archivos.

Las referencias directas a objetos inseguras permiten a los atacantes saltarse la autorización y acceder directamente a los recursos modificando el valor de un parámetro utilizado para apuntar directamente a un objeto. Dichos recursos pueden ser registros de bases de datos pertenecientes a otros usuarios, archivos del sistema, etc. Esto se debe al hecho de que la aplicación toma la entrada suministrada por el usuario y la utiliza para recuperar un objeto sin realizar suficientes comprobaciones de autorización.

**Cómo realizar la prueba**
Para comprobar esta vulnerabilidad, la persona encargada de realizar la prueba primero tiene que trazar un mapa de todas las ubicaciones de la aplicación en las que la entrada del usuario se utiliza para hacer referencia a objetos directamente. Por ejemplo, los lugares donde la entrada del usuario se utiliza para acceder a una fila de base de datos, un archivo, páginas de la aplicación y más. A continuación, el evaluador debe modificar el valor del parámetro utilizado para hacer referencia a objetos y evaluar si es posible recuperar objetos pertenecientes a otros usuarios o eludir la autorización.

**Autenticar primero, abusar de la autorización después**

Muchos problemas de control de acceso son susceptibles de ser atacados por un usuario autenticado pero no autorizado. Por lo tanto, empecemos por autenticarnos legítimamente. Después, buscaremos formas de eludir o abusar de la autorización.

**Observación de diferencias y comportamientos**
Un principio consistente del lado ofensivo de AppSec es observar las diferencias de la respuesta cruda a lo que es visible. En otras palabras (como ya habrás notado en la lección de filtrado del lado del cliente), a menudo hay datos en la respuesta sin procesar que no aparecen en la pantalla/página.

Ejercicio: 

- Profile
    - name: Tom Cat
    - color: yellow
    - size:small

En este ejercicio que presenta la aplicacion de WebGoat, lo que tenemos que hacer es es ver lo que el servidor nos responde ante la request que se envia cuando hacemos click en el metodo **View Profile.** Lo que esta pasando por detras es que se esta enviando una request del tipo GET (metodo http). Para resolver el problema debemos capturar esa request con le herramienta Burpsuite, luego una ves que encontramos el metodo HTTP GET que hace referencia a esta leccion debemos enviarlo al **repeater** para poder ver lo que nos devuelve el servidor.

**Adivinar y predecir patrones**
Ver su propio perfil de otra manera
Muchas aplicaciones tienen roles en los que un usuario elevado puede acceder al contenido de otro. En ese caso, simplemente /profile no funcionará ya que los datos de sesión/autenticación del propio usuario no nos dirán qué perfil quiere ver. Entonces, ¿cuál crees que es un patrón probable para ver tu propio perfil explícitamente usando una referencia directa a un objeto?

### Referencias de objetos seguras

**Empezar por el final**
¿Tiene documentado el control de acceso? Si no lo tiene, ¿cómo puede hacerlo cumplir? El control de acceso está definido por la lógica de negocio que guía la aplicación y/o la privacidad y otras leyes.

**Control de acceso horizontal y vertical**
A menudo pensamos en el control de acceso en términos de "roles" (usuario, usuario avanzado, administrador, etc.). Sin embargo, como hemos visto en los ejercicios anteriores, los usuarios con el mismo "rol" pueden acceder a los datos de los demás. Se trata de un control de acceso horizontal. Ambos deben aplicarse.

### **Audit Access**

As displayed in the above example, your access control rules should include provisions of what access is logged. For example, if a super-user or admin can edit other’s profiles … That is something that should be logged. Other examples would include detected violations or attempts to violate access control mechanisms.

### **Using Indrect References**

No muchas aplicaciones lo emplean, pero puedes usar referencias indirectas. En este caso, puede ejecutar sus referencias a través de un hash, codificación u otra función en el servidor para que el id que el cliente ve no es la referencia real que el servidor maneja. Esto reducirá un poco la eficiencia (una compensación común para la seguridad) y todavía está sujeto a ser adivinado, forzado o ingeniería inversa.

Este enfoque no debería ser la única protección utilizada. Puede utilizarse como una capa adicional. El servidor debe implementar la lógica de asignación de referencias cliente (indirectas) a servidor (directas).

### **Access Control & APIs**

Muchas veces, las API o los puntos finales RESTFul se basan en la oscuridad , una "clave" estática, o la falta de imaginación por parte del usuario para controlar el acceso. Buenas opciones como los Tokens Web JSON firmados digitalmente ([https://jwt.io](https://jwt.io/)) son una buena opción para la autenticación y el control de acceso a la API utilizando una combinación de las declaraciones y una firma digital/criptográfica para validar al consumidor. Otros estándares emergentes como Secure Token Binding prometen un "estado criptográfico" para los servicios web en las cabeceras de las peticiones …https://tools.ietf.org/html/draft-ietf-tokbind-protocol-10

### ****Missing Function Level Access Control (Falta el control de acceso a nivel de función)****

****IDOR vs Missing Function Level Access Control****

La distinción más hecha es que IDOR es más una cuestión de control de acceso 'horizontal' o 'lateral', y el control de acceso a nivel de función que falta 'expone funcionalidad'. Aunque la lección de IDOR aquí demuestra como la funcionalidad también puede ser expuesta (al menos a otro usuario en el mismo rol), veremos otras formas en que la funcionalidad puede ser expuesta.

Si la comprobación de autenticación en los gestores de peticiones sensibles es insuficiente o inexistente, la vulnerabilidad puede clasificarse como Falta de control de acceso a nivel de función.

Un ejemplo de esto sería que un usuario no autorizado pudiera acceder a una URL que contenga información sensible o que exponga funcionalidades destinadas únicamente a usuarios autorizados. Otro ejemplo de un tipo común de esta vulnerabilidad sería simplemente ocultar una función al usuario, pero permitiendo la petición si el usuario es capaz de averiguar cómo llevarla a cabo.

En cierto modo, esta categoría de vulnerabilidades es muy similar a IDOR sobre la que hemos escrito anteriormente. Para simplificar, se puede decir que la diferencia es que IDOR expone información yendo a una URL que un usuario normal no debería conocer, mientras que esta categoría implica vulnerabilidades que exponen funcionalidad en lugar de información. Las vulnerabilidades de control de acceso a nivel de función también pueden requerir más del atacante que enumerar una URL.

**Explotabilidad**

Detectar y aprovechar esta vulnerabilidad se considera fácil. A menudo, todo lo que se necesita es que el atacante intente una acción específica que debería requerir autenticación y si la solicitud tiene éxito, la página se considera vulnerable. Lo que es difícil de hacer aquí es averiguar cada página que está en riesgo o característica que potencialmente podría conducir a algo peligroso.

**How to discover (Como descubrir esta vulnerabilidad)**

Una forma de descubrir la falta de control de acceso a nivel de función es navegar por el sitio web mientras se está conectado y registrar todas las páginas visitadas. El siguiente paso es cerrar la sesión y volver a visitar todas las páginas. Si obtiene el mismo resultado, es probable que exista esta vulnerabilidad. Algunos proxies hechos para pruebas de seguridad soportan este tipo de análisis por defecto

Otra forma es simplemente forzar diferentes rutas. Un ejemplo puede ser /admin, /settings o similares que sólo un administrador debería poder visitar. Si cualquier usuario puede acceder a ellas, se consideraría una vulnerabilidad. Esto también se denomina navegación forzada, que, simplificado, consiste en enumerar y acceder a recursos que no están referenciados por la aplicación, pero que siguen siendo accesibles.

Si se lleva a cabo un análisis del código, se puede identificar el patrón en el que se procesa una solicitud privilegiada, lo que facilita la comprensión del funcionamiento del patrón de autorización. De este modo, es posible descubrir lugares en los que no se aplica el mismo proceso, pero la solicitud sigue considerándose sensible.

### Cabecera (header) de una request o response HTTP

Existen varias cabeceras que se pueden incluir en una solicitud HTTP (request), pero las cabeceras obligatorias y comunes son:

- **Host**: especifica el nombre de dominio o dirección IP del servidor web al que se está enviando la solicitud.
- **User-Agent**: identifica el cliente que está realizando la solicitud, como un navegador web o una aplicación móvil.
- **Accept**: indica los tipos de contenido que el cliente acepta como respuesta. Por ejemplo, "Accept: application/json" indica que el cliente acepta una respuesta en formato JSON.
- **Content-Type**: en una solicitud POST o PUT, indica el tipo de contenido que se está enviando en el cuerpo de la solicitud, como "Content-Type: application/json" para indicar que el cuerpo de la solicitud contiene datos en formato JSON.
- **Content-Length**: en una solicitud POST o PUT, indica la longitud en bytes del cuerpo de la solicitud.
- **Authorization**: proporciona credenciales de autenticación para acceder a recursos protegidos en el servidor.

Además, otras cabeceras opcionales comunes incluyen:

- **Cache-Control**: especifica las directivas de almacenamiento en caché que se deben aplicar a la respuesta.
- **Accept-Language**: indica los idiomas que el cliente acepta para la respuesta.
- **Referer**: indica la URL de la página web que llevó al cliente a realizar la solicitud actual.
- **Cookie**: proporciona información de estado de sesión almacenada en el cliente.
- **If-None-Match**: en una solicitud GET, indica que el cliente solo desea recibir la respuesta si la versión actual del recurso no coincide con el valor del campo ETag proporcionado.
- **If-Modified-Since**: en una solicitud GET, indica que el cliente solo desea recibir la respuesta si el recurso ha sido modificado después de la fecha proporcionada.

# ****Spoofing an Authentication Cookie****

## Concepto

Las cookies de autenticación se utilizan para servicios que requieren autenticación, cuando el usuario inicia sesión con un nombre de usuario y una contraseña personales, el servidor valida las credenciales proporcionadas y, si son válidas, crea una sesión.

Cada sesión suele tener un ID único que identifica la sesión del usuario; cuando el servidor devuelve la respuesta al usuario, incluye una cabecera Set-Cookie que contiene, entre otras cosas, el nombre y el valor de la cookie.

La cookie de autenticación suele almacenarse en el lado del cliente y del servidor.

Por un lado, tener la cookie almacenada en el lado del cliente implica que puede ser robada explotando ciertas vulnerabilidades o interceptada utilizando ataques man in the middle o XSS. Por otro, los valores de las cookies se pueden adivinar si se puede obtener el algoritmo de generación de la cookie.

Muchas aplicaciones iniciarán automáticamente la sesión de un usuario si se proporciona la cookie de autenticación correcta.

## Objetivos

El usuario debe ser capaz de adivinar el algoritmo de generación de cookies y saltarse el mecanismo de autenticación iniciando sesión como un usuario diferente.

### **Ejercicio practico**

Eludir el mecanismo de autenticación falsificando una cookie de autenticación.

**Notas sobre el sistema de acceso**

- Cuando se envía una cookie de autenticación, el sistema iniciará la sesión del usuario directamente si la cookie es válida.
- Cuando no se envía una cookie, pero las credenciales proporcionadas son correctas, el sistema creará una cookie de autenticación.
- El inicio de sesión será denegado en cualquier otro caso.
- Preste atención al mensaje de respuesta que recibirá durante los ataques.

Credenciales conocidas:

| user name | password |
| --- | --- |
| webgoat | webgoat |
| admin | admin |

**Objetivo**

Cuando sepa cómo se genera la cookie de autenticación, intente falsificar la cookie e inicie sesión como Tom.

**DATOS ENCOTRADOS**

Primero que una cookie de autentincacion es algun tipo de dato indetificable para un usuario o una session especifica, que luego se codifican en un token que el navegador guarda al autenticarse. Generalmente es una identificacion de usuario  o un nombre de usuacio cifrado. Lo metodos que se utilizan muchas veces son base64 o codificacion hexadecimal.

La codificacion consiste en tomar una cadena y cambiar cada caracter a un valor diferente. Esta cadena puede ser predecible si se conoce como fue codificada. Otra cosa a saber es que una cadena codificada puede codificarse una y otras vez y usando diferentes metodos de codificacion.

El problema consiste en tratar de decodificar el metodo que se esta utilizando para codificar la cookie y luego poder recrear una cookie con nuestros datos, lo que permitira falsificar la autenticacion.

User webgoat

- **spoof_auth**=NGM0YTcxNTM1YTU3NDU2MjQzNGE 3NDYxNmY2NzYyNjU3Nw==

User admin

- **spoof_auth**=NGM0YTcxNTM1YTU3NDU2MjQzNGE3NDYxNmY2NzYyNjU3Nw
- **spoof_auth=**NGM0YTcxNTM1YTU3NDU2MjQzNGE2ZTY5NmQ2NDYx

Con estos datos de spoof_auth podemos ver que estan codificadas en bas64, por ende podemos decodificarlas con la siguiente pagina: https://www.base64decode.org/

Una ves que decodificamos por ejemplo la **spoof_auth**=NGM0YTcxNTM1YTU3NDU2MjQzNGE3NDYxNmY2NzYyNjU3Nw podemos ver que lo obtenido es lo siguiente 4c4a71535a574562434a74616f67626577 . Esto esta codificado con otro metodo. 

pero parece dificil de decifrar que metodo es, pero si a lo obtenido se le presta atencio se puede ver que separando de 2 en 2 es una codificacion con hexadecimal, 4c 4a 71 53 5a 57 45 62 43 4a 74 61 6f 67 62 65 77

Para decodificarlo se puede hacer de manera manual o usando una pagina com esta https://cryptii.com/pipes/hex-decoder

lo que nos devuelve LJqSZWEbCJtaogbew es una cadena que contiene el nombre del usuario pero al reves, por lo que podemos hacer un codigo de python para practicar y dar vuelta esa cadena.

Para poder iniciar session como tom lo que tenemos que hacer es el proceso inverso, obtener la cadena reversa con la palabra de tom y luego codificarlo con hexadecimal y finalmente en base64.

Entonces tom quedaria de la siguiente forma:

- LJqSZWEbCJmot — > dado vuelta el con el nombre
- 4c4a71535a574562434a6d6f74 —> hexadecimal
- NGM0YTcxNTM1YTU3NDU2MjQzNGE2ZDZmNzQ= —> en base64

# Cryptographic Failures

Esta lección explica los diferentes tipos de técnicas criptográficas que se utilizan habitualmente en las aplicaciones web.
